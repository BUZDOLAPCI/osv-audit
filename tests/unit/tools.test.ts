import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { parseDependencies } from '../../src/tools/parse.js';
import { osvQuery } from '../../src/tools/query.js';
import { suggestFixes } from '../../src/tools/suggest.js';

// ============================================================================
// parse_dependencies Tests
// ============================================================================

describe('parseDependencies', () => {
  describe('package-lock.json parsing', () => {
    it('should parse package-lock v2 format', async () => {
      const packageLock = JSON.stringify({
        name: 'test-project',
        version: '1.0.0',
        lockfileVersion: 2,
        packages: {
          '': {
            name: 'test-project',
            version: '1.0.0',
          },
          'node_modules/lodash': {
            version: '4.17.21',
          },
          'node_modules/express': {
            version: '4.18.2',
          },
        },
      });

      const result = await parseDependencies({
        text: packageLock,
        manifest_type: 'package-lock',
      });

      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.data.dependencies).toHaveLength(2);
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'npm',
          name: 'lodash',
          version: '4.17.21',
        });
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'npm',
          name: 'express',
          version: '4.18.2',
        });
      }
    });

    it('should parse package-lock v1 format', async () => {
      const packageLock = JSON.stringify({
        name: 'test-project',
        lockfileVersion: 1,
        dependencies: {
          lodash: { version: '4.17.21' },
          axios: { version: '1.6.0' },
        },
      });

      const result = await parseDependencies({
        text: packageLock,
        manifest_type: 'package-lock',
      });

      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.data.dependencies).toHaveLength(2);
        expect(result.data.count).toBe(2);
      }
    });

    it('should handle empty packages', async () => {
      const packageLock = JSON.stringify({
        name: 'test-project',
        packages: {},
      });

      const result = await parseDependencies({
        text: packageLock,
        manifest_type: 'package-lock',
      });

      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.data.dependencies).toHaveLength(0);
        expect(result.meta.warnings).toContain('No dependencies found in manifest');
      }
    });
  });

  describe('requirements.txt parsing', () => {
    it('should parse standard requirements format', async () => {
      const requirements = `
# Comment line
requests==2.31.0
flask>=2.0.0
django~=4.2.0
numpy
-e git+https://github.com/test/repo.git
`;

      const result = await parseDependencies({
        text: requirements,
        manifest_type: 'requirements',
      });

      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'PyPI',
          name: 'requests',
          version: '2.31.0',
        });
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'PyPI',
          name: 'flask',
          version: '2.0.0',
        });
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'PyPI',
          name: 'django',
          version: '4.2.0',
        });
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'PyPI',
          name: 'numpy',
          version: '*',
        });
      }
    });

    it('should handle extras in package names', async () => {
      const requirements = 'requests[security]==2.31.0';

      const result = await parseDependencies({
        text: requirements,
        manifest_type: 'requirements',
      });

      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.data.dependencies[0]).toEqual({
          ecosystem: 'PyPI',
          name: 'requests',
          version: '2.31.0',
        });
      }
    });
  });

  describe('yarn.lock parsing', () => {
    it('should parse yarn.lock format', async () => {
      const yarnLock = `
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

lodash@^4.17.0:
  version "4.17.21"
  resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.21.tgz"
  integrity sha512-abc123

"express@^4.0.0", express@^4.18.0:
  version "4.18.2"
  resolved "https://registry.yarnpkg.com/express/-/express-4.18.2.tgz"
`;

      const result = await parseDependencies({
        text: yarnLock,
        manifest_type: 'yarn-lock',
      });

      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'npm',
          name: 'lodash',
          version: '4.17.21',
        });
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'npm',
          name: 'express',
          version: '4.18.2',
        });
      }
    });
  });

  describe('pnpm-lock.yaml parsing', () => {
    it('should parse pnpm-lock format', async () => {
      const pnpmLock = `
lockfileVersion: '6.0'

packages:

  /lodash@4.17.21:
    resolution: {integrity: sha512-abc}
    dev: false

  /@types/node@20.10.0:
    resolution: {integrity: sha512-xyz}
    dev: true
`;

      const result = await parseDependencies({
        text: pnpmLock,
        manifest_type: 'pnpm-lock',
      });

      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'npm',
          name: 'lodash',
          version: '4.17.21',
        });
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'npm',
          name: '@types/node',
          version: '20.10.0',
        });
      }
    });
  });

  describe('poetry.lock parsing', () => {
    it('should parse poetry.lock TOML format', async () => {
      const poetryLock = `
[[package]]
name = "requests"
version = "2.31.0"
description = "Python HTTP library"
category = "main"

[[package]]
name = "flask"
version = "2.3.0"
description = "Web framework"
category = "main"
`;

      const result = await parseDependencies({
        text: poetryLock,
        manifest_type: 'poetry-lock',
      });

      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'PyPI',
          name: 'requests',
          version: '2.31.0',
        });
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'PyPI',
          name: 'flask',
          version: '2.3.0',
        });
      }
    });
  });

  describe('go.mod parsing', () => {
    it('should parse go.mod format', async () => {
      const goMod = `
module example.com/mymodule

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/google/uuid v1.4.0 // indirect
)

require github.com/stretchr/testify v1.8.4
`;

      const result = await parseDependencies({
        text: goMod,
        manifest_type: 'go-mod',
      });

      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'Go',
          name: 'github.com/gin-gonic/gin',
          version: '1.9.1',
        });
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'Go',
          name: 'github.com/google/uuid',
          version: '1.4.0',
        });
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'Go',
          name: 'github.com/stretchr/testify',
          version: '1.8.4',
        });
      }
    });
  });

  describe('Cargo.lock parsing', () => {
    it('should parse Cargo.lock TOML format', async () => {
      const cargoLock = `
[[package]]
name = "serde"
version = "1.0.193"
source = "registry+https://github.com/rust-lang/crates.io-index"

[[package]]
name = "tokio"
version = "1.35.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
`;

      const result = await parseDependencies({
        text: cargoLock,
        manifest_type: 'cargo-lock',
      });

      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'crates.io',
          name: 'serde',
          version: '1.0.193',
        });
        expect(result.data.dependencies).toContainEqual({
          ecosystem: 'crates.io',
          name: 'tokio',
          version: '1.35.0',
        });
      }
    });
  });

  describe('error handling', () => {
    it('should return error for empty input', async () => {
      const result = await parseDependencies({
        text: '',
        manifest_type: 'package-lock',
      });

      expect(result.ok).toBe(false);
      if (!result.ok) {
        expect(result.error.code).toBe('INVALID_INPUT');
      }
    });

    it('should return error for invalid JSON', async () => {
      const result = await parseDependencies({
        text: 'not valid json',
        manifest_type: 'package-lock',
      });

      expect(result.ok).toBe(false);
      if (!result.ok) {
        expect(result.error.code).toBe('PARSE_ERROR');
      }
    });
  });
});

// ============================================================================
// osv_query Tests
// ============================================================================

describe('osvQuery', () => {
  const createMockFetch = (response: unknown, status = 200) => {
    return vi.fn().mockResolvedValue({
      ok: status >= 200 && status < 300,
      status,
      headers: new Map(),
      json: () => Promise.resolve(response),
    });
  };

  it('should query OSV API and return vulnerabilities', async () => {
    const mockResponse = {
      results: [
        {
          vulns: [
            {
              id: 'GHSA-xxxx-yyyy-zzzz',
              summary: 'Critical vulnerability in lodash',
              modified: '2024-01-01T00:00:00Z',
              affected: [
                {
                  package: { ecosystem: 'npm', name: 'lodash' },
                  ranges: [
                    {
                      type: 'SEMVER',
                      events: [{ introduced: '0' }, { fixed: '4.17.21' }],
                    },
                  ],
                },
              ],
              severity: [{ type: 'CVSS_V3', score: '9.8' }],
              aliases: ['CVE-2021-12345'],
              references: [{ type: 'WEB', url: 'https://example.com' }],
            },
          ],
        },
      ],
    };

    const mockFetch = createMockFetch(mockResponse);

    const result = await osvQuery(
      {
        dependencies: [{ ecosystem: 'npm', name: 'lodash', version: '4.17.20' }],
      },
      mockFetch as unknown as typeof fetch
    );

    expect(result.ok).toBe(true);
    if (result.ok) {
      expect(result.data.total_vulnerabilities).toBe(1);
      expect(result.data.results[0]?.vulnerabilities[0]).toMatchObject({
        id: 'GHSA-xxxx-yyyy-zzzz',
        severity: 'CRITICAL',
        fixed_versions: ['4.17.21'],
        aliases: ['CVE-2021-12345'],
      });
    }

    expect(mockFetch).toHaveBeenCalledWith(
      expect.stringContaining('/v1/querybatch'),
      expect.objectContaining({
        method: 'POST',
        body: expect.stringContaining('lodash'),
      })
    );
  });

  it('should handle no vulnerabilities found', async () => {
    const mockResponse = {
      results: [{ vulns: [] }],
    };

    const mockFetch = createMockFetch(mockResponse);

    const result = await osvQuery(
      {
        dependencies: [{ ecosystem: 'npm', name: 'safe-package', version: '1.0.0' }],
      },
      mockFetch as unknown as typeof fetch
    );

    expect(result.ok).toBe(true);
    if (result.ok) {
      expect(result.data.total_vulnerabilities).toBe(0);
      expect(result.meta.warnings).toContain(
        'No vulnerabilities found for the provided dependencies'
      );
    }
  });

  it('should handle rate limiting', async () => {
    const mockFetch = vi.fn().mockResolvedValue({
      ok: false,
      status: 429,
      headers: new Map([['Retry-After', '60']]),
    });

    const result = await osvQuery(
      {
        dependencies: [{ ecosystem: 'npm', name: 'lodash', version: '4.17.20' }],
      },
      mockFetch as unknown as typeof fetch
    );

    expect(result.ok).toBe(false);
    if (!result.ok) {
      expect(result.error.code).toBe('RATE_LIMITED');
    }
  });

  it('should handle API errors', async () => {
    const mockFetch = createMockFetch({}, 500);

    const result = await osvQuery(
      {
        dependencies: [{ ecosystem: 'npm', name: 'lodash', version: '4.17.20' }],
      },
      mockFetch as unknown as typeof fetch
    );

    expect(result.ok).toBe(false);
    if (!result.ok) {
      expect(result.error.code).toBe('UPSTREAM_ERROR');
    }
  });

  it('should handle network errors', async () => {
    const mockFetch = vi.fn().mockRejectedValue(new Error('Network error'));

    const result = await osvQuery(
      {
        dependencies: [{ ecosystem: 'npm', name: 'lodash', version: '4.17.20' }],
      },
      mockFetch as unknown as typeof fetch
    );

    expect(result.ok).toBe(false);
    if (!result.ok) {
      expect(result.error.code).toBe('UPSTREAM_ERROR');
    }
  });

  it('should return error for empty dependencies array', async () => {
    const result = await osvQuery({ dependencies: [] });

    expect(result.ok).toBe(false);
    if (!result.ok) {
      expect(result.error.code).toBe('INVALID_INPUT');
    }
  });
});

// ============================================================================
// suggest_fixes Tests
// ============================================================================

describe('suggestFixes', () => {
  it('should suggest upgrades for vulnerable packages', async () => {
    const vulnResults = [
      {
        dependency: { ecosystem: 'npm', name: 'lodash', version: '4.17.20' },
        vulnerabilities: [
          {
            id: 'GHSA-xxxx-yyyy-zzzz',
            summary: 'Prototype pollution',
            severity: 'CRITICAL',
            severity_score: 9.8,
            fixed_versions: ['4.17.21'],
            aliases: ['CVE-2021-12345'],
            references: [{ type: 'WEB', url: 'https://example.com' }],
          },
        ],
      },
    ];

    const result = await suggestFixes({ vuln_results: vulnResults });

    expect(result.ok).toBe(true);
    if (result.ok) {
      expect(result.data.suggestions).toHaveLength(1);
      expect(result.data.suggestions[0]).toMatchObject({
        package: 'lodash',
        ecosystem: 'npm',
        current_version: '4.17.20',
        suggested_version: '4.17.21',
        priority: 'critical',
        action: 'upgrade',
      });
      expect(result.data.summary.by_priority.critical).toBe(1);
    }
  });

  it('should sort suggestions by priority', async () => {
    const vulnResults = [
      {
        dependency: { ecosystem: 'npm', name: 'low-priority', version: '1.0.0' },
        vulnerabilities: [
          {
            id: 'LOW-1',
            summary: 'Low severity issue',
            severity: 'LOW',
            severity_score: 2.0,
            fixed_versions: ['1.0.1'],
            aliases: [],
            references: [],
          },
        ],
      },
      {
        dependency: { ecosystem: 'npm', name: 'critical-priority', version: '1.0.0' },
        vulnerabilities: [
          {
            id: 'CRITICAL-1',
            summary: 'Critical issue',
            severity: 'CRITICAL',
            severity_score: 9.8,
            fixed_versions: ['1.0.1'],
            aliases: [],
            references: [],
          },
        ],
      },
    ];

    const result = await suggestFixes({ vuln_results: vulnResults });

    expect(result.ok).toBe(true);
    if (result.ok) {
      expect(result.data.suggestions[0]?.package).toBe('critical-priority');
      expect(result.data.suggestions[1]?.package).toBe('low-priority');
    }
  });

  it('should handle packages with no fixed version', async () => {
    const vulnResults = [
      {
        dependency: { ecosystem: 'npm', name: 'no-fix', version: '1.0.0' },
        vulnerabilities: [
          {
            id: 'VULN-1',
            summary: 'Issue with no fix',
            severity: 'HIGH',
            severity_score: 8.0,
            fixed_versions: [],
            aliases: [],
            references: [],
          },
        ],
      },
    ];

    const result = await suggestFixes({ vuln_results: vulnResults });

    expect(result.ok).toBe(true);
    if (result.ok) {
      expect(result.data.suggestions[0]).toMatchObject({
        suggested_version: null,
        action: 'review',
      });
      expect(result.data.suggestions[0]?.notes).toContain(
        'No fixed version available - consider alternative packages or manual mitigation'
      );
    }
  });

  it('should warn about major version upgrades', async () => {
    const vulnResults = [
      {
        dependency: { ecosystem: 'npm', name: 'major-upgrade', version: '1.0.0' },
        vulnerabilities: [
          {
            id: 'VULN-1',
            summary: 'Issue requiring major upgrade',
            severity: 'MEDIUM',
            severity_score: 5.0,
            fixed_versions: ['2.0.0'],
            aliases: [],
            references: [],
          },
        ],
      },
    ];

    const result = await suggestFixes({ vuln_results: vulnResults });

    expect(result.ok).toBe(true);
    if (result.ok) {
      expect(result.data.suggestions[0]?.notes).toContain(
        'Warning: This is a major version upgrade - review changelog for breaking changes'
      );
    }
  });

  it('should include CVE references in notes', async () => {
    const vulnResults = [
      {
        dependency: { ecosystem: 'npm', name: 'with-cve', version: '1.0.0' },
        vulnerabilities: [
          {
            id: 'VULN-1',
            summary: 'Issue',
            severity: 'HIGH',
            severity_score: 8.0,
            fixed_versions: ['1.0.1'],
            aliases: ['CVE-2024-12345', 'CVE-2024-67890'],
            references: [],
          },
        ],
      },
    ];

    const result = await suggestFixes({ vuln_results: vulnResults });

    expect(result.ok).toBe(true);
    if (result.ok) {
      const notes = result.data.suggestions[0]?.notes.join(' ');
      expect(notes).toContain('CVE-2024-12345');
      expect(notes).toContain('CVE-2024-67890');
    }
  });

  it('should handle empty vulnerability results', async () => {
    const result = await suggestFixes({ vuln_results: [] });

    expect(result.ok).toBe(true);
    if (result.ok) {
      expect(result.data.suggestions).toHaveLength(0);
      expect(result.meta.warnings).toContain(
        'No vulnerabilities found - no fix suggestions needed'
      );
    }
  });

  it('should handle packages with multiple vulnerabilities', async () => {
    const vulnResults = [
      {
        dependency: { ecosystem: 'npm', name: 'multi-vuln', version: '1.0.0' },
        vulnerabilities: [
          {
            id: 'VULN-1',
            summary: 'First issue',
            severity: 'HIGH',
            severity_score: 8.0,
            fixed_versions: ['1.0.1'],
            aliases: [],
            references: [],
          },
          {
            id: 'VULN-2',
            summary: 'Second issue',
            severity: 'CRITICAL',
            severity_score: 9.5,
            fixed_versions: ['1.0.2'],
            aliases: [],
            references: [],
          },
        ],
      },
    ];

    const result = await suggestFixes({ vuln_results: vulnResults });

    expect(result.ok).toBe(true);
    if (result.ok) {
      // Should have critical priority (highest of the two)
      expect(result.data.suggestions[0]?.priority).toBe('critical');
      // Should suggest the minimum version that fixes all
      expect(result.data.suggestions[0]?.suggested_version).toBe('1.0.1');
      // Should list all fixed vulnerabilities
      expect(result.data.suggestions[0]?.vulnerabilities_fixed).toContain('VULN-1');
      expect(result.data.suggestions[0]?.vulnerabilities_fixed).toContain('VULN-2');
    }
  });
});
